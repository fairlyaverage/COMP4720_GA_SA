import numpy as np
import matplotlib.pyplot as plt
import time

# Load city coordinates from file
city_coords = np.loadtxt('city_coords.txt')

# Define SA parameters
T_start = 1.0  # Starting temperature
T_end = 0.001  # Ending temperature
n_steps = 10000  # Number of steps
n_airports = 3  # Number of airports to place

# Define energy function
def energy(state):
    # Compute distance to nearest airport for each city
    dists = np.min(np.sqrt(np.sum((city_coords - state.reshape(-1, 2))**2, axis=1)))
    # Return sum of squared distances
    return np.sum(dists**2)

# Define transition function
def transition(state, T):
    # Randomly move one airport to a new position
    new_state = state.copy()
    idx = np.random.choice(n_airports)
    new_state[idx*2:idx*2+2] += np.random.normal(0, T, size=2)
    return new_state

# Initialize state
state = np.random.uniform(size=n_airports*2)

# Evolution loop
T = T_start
energies = [energy(state)]
start_time = time.time()
for i in range(n_steps):
    # Update temperature
    T = T_start * (T_end/T_start)**(i/n_steps)
    # Make a random transition
    new_state = transition(state, T)
    # Compute energy difference
    delta_E = energy(new_state) - energy(state)
    # Decide whether to accept the new state
    if delta_E < 0 or np.random.rand() < np.exp(-delta_E/T):
        state = new_state
        energies.append(energy(state))

# Extract airport locations from final state
airports = state.reshape(-1, 2)

# Plot results
plt.figure()
plt.scatter(city_coords[:, 0], city_coords[:, 1], marker='.', color='gray')
plt.scatter(airports[:, 0], airports[:, 1], marker='*', color='red')
plt.show()

# Calculate time taken
end_time = time.time()
time_taken = end_time - start_time
print("Time taken to reach convergence:", time_taken, "seconds")

# Plot convergence
plt.figure()
plt.plot(energies)
plt.xlabel('Step')
plt.ylabel('Energy')
plt.title('Convergence Plot')
plt.show()



/*
This code calculates the time taken to reach convergence using the time module and the function time.time(). It also includes a plot of the convergence of the algorithm using Matplotlib.


Note that this code assumes that the city coordinates are stored in a text file called city_coords.txt, with one row per city and two columns for the x and y coordinates. You may need to modify this code to match your specific problem and data format.
*/


/*  Define mathematically

The optimization problem of placing n new airports in Romania such that the sum of squared distances from each city on the map to its nearest airport is minimized can be mathematically defined as follows:

Decision variables:

Let X be a matrix of size n x 2, where each row represents the coordinates of an airport to be placed. Specifically, X<sub>i,1</sub> and X<sub>i,2</sub> denote the x and y coordinates of the i-th airport, respectively, where i = 1, 2, ..., n.
Objective function:

Minimize the sum of squared distances from each city on the map to its nearest airport, which can be computed as:
php
Copy code
f(X) = ∑<sub>j=1</sub><sup>m</sup> (min<sub>i=1,2,...,n</sub> √((X<sub>i,1</sub> - x<sub>j</sub>)<sup>2</sup> + (X<sub>i,2</sub> - y<sub>j</sub>)<sup>2</sup>))<sup>2</sup>
where m is the total number of cities on the map, and (x<sub>j</sub>, y<sub>j</sub>) are the coordinates of the j-th city.

Constraints:

None, since the problem does not have any explicit constraints.
Simulated annealing can then be used to solve this optimization problem by defining a starting solution (i.e., a matrix of airport coordinates X), an initial temperature, a cooling schedule, and a neighborhood structure for generating candidate solutions. At each iteration, a candidate solution is generated by applying a small perturbation to the current solution, and the algorithm probabilistically accepts the candidate solution based on a probability function that depends on the current temperature and the change in the objective function. The algorithm continues until either a satisfactory solution is found, or a stopping criterion (such as reaching a maximum number of iterations) is met.

*/